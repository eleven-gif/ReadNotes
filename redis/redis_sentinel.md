# redis哨兵实现

## 哨兵介绍
redis主从复制模式主要是为了保证高可用以及分担主节点读压力，但是在master挂掉之后从节点需要成为主节点。主要存在几个问题

- 从节点晋升主节点需要人工干预
- 主节点写能力以及存储能力受单机限制

第一个问题可以通过Sentinel解决，第二个问题可以通过Cluster解决。

## 哨兵初始化
哨兵是一类特殊的redis节点，负责监控主节点状态，启动哨兵需要配置监控的主节点以及超时时间，哨兵启动之后会连接主节点，并通过主节点拿到所有的从节点以及其他哨兵节点从而建立连接。

## 哨兵运行
哨兵内部也有逻辑时钟

```c
void sentinelTimer(void) {
    // 先检查Sentinel是否需要进入TITL模式，更新最近一次执行Sentinel模式的周期函数的时间
    // 每秒10次，假设间隔为100ms，如果两次执行时间差距超过2s或为负数则认为系统异常进入TILT模式，如果已进入则推迟退出时间，可能由于负载过大，被阻塞，系统时钟变化等
    // 此模式下会继续监控，但不会进行任何操作例如故障转移
    sentinelCheckTiltCondition();
    // 对所有主节点进行监控
    // 这里会对主节点、主节点的从节点、主节点对应的sentinel节点进行监控
    // 判断是否完成故障迁移，完成之后会新节点晋升主节点，其他的全部变成从节点
    sentinelHandleDictOfRedisInstances(sentinel.masters);
    // 执行脚本
    sentinelRunPendingScripts();
    // 清理成功脚本，重试失败脚本
    sentinelCollectTerminatedScripts();
    // 超时脚本，杀掉，下次再执行
    sentinelKillTimedoutScripts();

    // 随机改变始终频率，使所有的哨兵分开对节点进行检测，并且在出故障时，选举进行故障切换的leader时大家不同时发请求，防止脑裂
    server.hz = CONFIG_DEFAULT_HZ + rand() % CONFIG_DEFAULT_HZ;
}
```

## 哨兵监控实现

1. 哨兵启动之后根据配置文件中的主节点去连接主节点，并对主/从节点建立订阅channel处理发来的hello
2. 定时查询监控节点状态，并及时发现离线节点，发现离线之后会询问监控此节点的哨兵，超过票数限制才会认为该节点下线
3. 主节点下线需要进行故障迁移，迁移开始之前要先通过raft选举一个哨兵的leader，然后对从节点进行筛选，剔除一些不选择的节点，剩下的排序(最低优先级，复制偏移量，runid字典序最小，runid相同命令更多的)选择一个从节点
4. 使从节点晋升为新的主节点，完成后通知其他从节点新的主节点